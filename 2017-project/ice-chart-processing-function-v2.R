################################################################
#  Script written by Paul Regular (Paul.Regular@dfo-mpo.gc.ca)  #
#  Created 201X-XX-XX, R version 3.X.x (201X-XX-XX)             #
#  Last modified by Paul Regular, Alejandro Buren, and Keith Lewis 2017-07.04 #
################################################################

# The purpose of this file is to store the funcitons required for:
  #1) eggAttr: function for extracting egg attributes from EGG_ATTR string
  #2) attrTab: extracting attribute table from raw e00 file (not 100% successful)
  #3) iceArea: using the attribute table to calculate total ice area
  #4) iceVolume: using attribute table to calculate total ice volume
  #5) plotIce: function for plotting ice charts
  #6) LookAt function


## Custom functions 

##' eggAttr()-----------------------------
##' function for extracting egg attributes from EGG_ATTR string - used in iceArea() to elegantly extract values from the EGG_ATTR string and calculate area
#' Egg data Attributes
#'
#' @param x where x is an object
#'
#' @return
#' @export
#'
#' @examples
#' 
eggAttr <- function(x) {
  if(any(grepl("_", x))) {
    sx <- strsplit(x, "_")
  } else {
    sx <- vector("list", length(x))
  }
  sx <- lapply(sx, function(i) {
    newi <- i
    if (length(i) == 0) {
      newi <- rep(NA, 17)
    } else {
      newi[newi == "@" | newi == "X"] <- NA
    }
    newi
  }
  )
  sx <- data.frame(do.call(rbind, sx))
  names(sx) <- c("E_CT","E_CA","E_CB","E_CC","E_CD","E_SO","E_SA","E_SB","E_SC","E_SD","E_SE","E_FA","E_FB","E_FC","E_FD","E_FE","E_CS")
  sx
}


##' attrTab()-----------------------------
##' function for extracting attribute table from raw e00 file (not 100% successful)
#' Attribute Table
#'
#' @param x = data 
#'
#' @return
#' @export
#'
#' @examples
attrTab <- function(x) {
  
  full.pattern <- c("Land", "No data", "Ice free", "Open water", 
                    "Fast ice", "Remote egg", "Bergy water", "Egg")
  partial.pattern <- c("Land", "No", "Ice", "Open", 
                       "Fast", "Remote", "Bergy", "Egg")
  p <- paste(partial.pattern, collapse = "|")
  i <- grep(p, x) # find matches to A_LEGEND types
  subx <- x[head(i, 1):tail(i, 1)]
  subi <- grep(p, subx) # revise i
  id <- aleg <- egg.attr <- rep(NA, length(subi))
  for(i in seq_along(subi)) {
    j <- regexpr(p, subx[subi[i]])
    aleg[i] <- regmatches(subx[subi[i]], j)
    id[i] <- as.integer(substr(subx[subi[i]], j-3, j-1)) # polygon id usually 3 characters before A_LEGEND text
    e <- paste(subx[subi[i]+1:2], collapse = "") # looks like EGG_ATTR text is 1-2 records ahead of A_LEGEND text
    if(grepl("_@_", e)) {
      j <- gregexpr("_", e)
      e <- substr(e, max(j[[1]])-35, max(j[[1]])+3)
      egg.attr[i] <- gsub("^\\s+|\\s+$", "", e) # clear spaces
    } else {
      egg.attr[i] <- NA
    }
  }
  attr.tab <- data.frame(ID = id, A_LEGEND = aleg, EGG_ATTR = egg.attr)
  attr.tab <- attr.tab[!is.na(attr.tab$ID), ] # chuck records missing id
  attr.tab <- attr.tab[!duplicated(attr.tab$ID), ] # remove duplicate IDs
  attr.tab <- cbind(attr.tab, eggAttr(attr.tab$EGG_ATTR)) # split egg attributes and add 
  attr.tab$A_LEGEND[is.na(attr.tab$A_LEGEND)] <- "No data"
  attr.tab$A_LEGEND <- full.pattern[match(attr.tab$A_LEGEND, partial.pattern)]
  row.names(attr.tab) <- attr.tab$ID
  attr.tab
}


##' eggAttr.cols()-------------------
## Turn the eggAttr data into columns that can be querried
#'
#' @param x = data, sub.egg object generated by the calcAreaVolume function
#'
#' @return x creates an expanded sub.egg object with with ice data in columns.  Purpose is to provide an easy way to subset egg data with eggAttr.query
#' @examples
## 
eggAttr.cols <- function(x) {
  # do we want to set up the columns first and populate them later?
  egg.cols <- gsub("@", "0", x$EGG_ATTR)
  egg.cols <- gsub("9\\+", "9.5", egg.cols)
  egg.cols <- strsplit(egg.cols, "_")
  egg.cols <- as.data.frame(do.call(rbind, egg.cols))
  colnames(egg.cols) <- c("CT","CA","CB","CC","CD","SO","SA","SB","SC","SD","SE","FA","FB","FC","FD","FE","CS")
  x <- cbind(x, egg.cols)
  return(x)
}


##' eggAttr.query() ---------------
##'query the egg/ice data for concentration and stage among polygons 
#'
#' @param x = data, sub.egg object generated by the calcAreaVolume function and modified by eggAttr.cols(),
#'    CT = total concentration - enter a vectcor, CA = concentration for thickest ice - optional, add others as needed
#'    SA = stage of development of the thickeest ice - enter a vector, SB concentration of second thickest ice - optional, add                          others as needed
#'
#' @return x creates a subset of the sub.egg data
#' @export
#'
#' @examples eggAttr.query(x = data, CT = ct, cA = NULL, SA = sa, SB = NULL)

eggAttr.query <- function(x = data, ct = NULL, sa = NULL){
  if(is.null(ct)) ct <- unique(x$CT) #if all values of CT are desired
  if(is.null(sa)) sa <- unique(x$SA) #if all values of SA are desired
  x <- subset(x, subset = CT %in% ct & SA %in% sa)
  return(x)
}

###########################################################
##' eggAttr.within() ---------------
##' query the egg/ice data for concentration and stage among polygons 
#'
#' @param x = data, sub.egg object generated by the calcAreaVolume function and modified by eggAttr.cols() 
#'
#' @return x creates a subset of the sub.egg data
#' @export
#'
#' @examples

withinPolyAreaA <- function(x = data) {
  for (i in 1:nrow(x)) {
    if (is.na(x$SA[i])) {
      x$AREA_NEW[i] <- 0
    } else {
      if (x$SA == 5) {
        x$AREA_NEW[i] <- x$AREA[i] * (as.numeric(x$CA[i]) / 10)
      } else {
        x$AREA_NEW[i] <- 0
      }
      
    }
  }
  return(x)
}

###########################################################

##' iceArea()-----------------------------
##'uses attribute table to calculate total ice area
#'
#' @param x = data, sub.egg object generated by the calcAreaVolume function and modified by eggAttr.cols(),and egg.Attr.query()
#'
#' @return x maintains the sub.egg data
#'          icesum - the sum of the ice in the SPDF after the subsets
#' @export
#'
#' @examples
#' 
iceArea <- function(x, ct = NULL, sa = NULL) {
  x <- eggAttr.cols(x)
  x <- eggAttr.query(x, ct = ct, sa = sa)# try with ....
  if(nrow(x) == 0){
    area <- coverage <- 0    
  } else {
    area <- x$AREA
    #area <- x$AREA_NEW
    etab <- eggAttr(x$EGG_ATTR)
    coverage <- as.numeric(gsub("\\+", ".5", etab$E_CT))/10 # convert total coverage to percent
  }
  #sum(area * coverage, na.rm = TRUE)
  icesum <- sum(area * coverage, na.rm = TRUE)
  return(list(x, icesum))
}


##' iceVolume()-----------------------------
##' uses attribute table to calculate total ice volume
#' Title Ice Volume
#'
#' @param x 
#'
#' @return
#' @export
#'
#' @examples
iceVolume <- function(x) {
  stab <- data.frame(thick = c(10.0, 10.0, 20.0, 12.5, 22.5, 30.0, 50.0, 40.0, 60.0, 95.0, 120.0),
                     code = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "1.", "4.")) # from table below
  area <- x$AREA
  etab <- eggAttr(x$EGG_ATTR)
  etab$E_CA[is.na(etab$E_CA)] <- etab$E_CT[is.na(etab$E_CA)] # place total concentration in column a if only one ice type
  ct <- as.numeric(gsub("\\+", ".5", etab$E_CT))/10
  ca <- as.numeric(gsub("\\+", ".5", etab$E_CA))/10 # convert coverage to percent
  cb <- as.numeric(gsub("\\+", ".5", etab$E_CB))/10 
  cc <- as.numeric(gsub("\\+", ".5", etab$E_CC))/10 
  cd <- as.numeric(gsub("\\+", ".5", etab$E_CD))/10
  i <- which(is.na(etab$E_CD) & !is.na(etab$E_SD))
  if(length(i) > 0) cd[i] <- ct[i] - (ca[i] + cb[i] + cc[i]) # rule from ice manual
  ta <- stab$thick[match(etab$E_SA, stab$code)] * 1e-5 # thickness converted to km
  tb <- stab$thick[match(etab$E_SB, stab$code)] * 1e-5 # thickness converted to km
  tc <- stab$thick[match(etab$E_SC, stab$code)] * 1e-5 # thickness converted to km
  td <- stab$thick[match(etab$E_SD, stab$code)] * 1e-5 # thickness converted to km
  vtab <- data.frame(a=ca*ta*area, b=cb*tb*area, c=cc*tc*area, d=cd*td*area) # volume table
  vtab[is.na(vtab)] <- 0
  sum(rowSums(vtab))
}


##' plotIce()-----------------------------
##' function for plotting ice charts
#'
#' @param x 
#' @param main 
#'
#' @return
#' @export
#'
#' @examples
plotIce <- function(x, main = "") {
  Blues <- colorRampPalette(brewer.pal(8, "Blues"))
  x <- spTransform(x, CRS("+proj=longlat +datum=WGS84"))
  ct <- as.numeric(gsub("\\+", ".5", eggAttr(x$EGG_ATTR)$E_CT))/10
  ct[is.na(ct)] <- 0
  cols <- rgb(1, 1, 1, ct)
  par(mar = c(3, 3, 3, 3), xaxs = "i", yaxs = "i")
  plot(x, axes = TRUE, col = "#084594", border = "#084594", main = main)
  plot(x, col = cols, border = NA, add = TRUE)
  plot(x[x$A_LEGEND == "Land", ], col = "grey60", border = "grey40", lwd = 0.5, add = TRUE)
}


##' e00_to_SpatialPolygonDataframe() ----------------------------------
##' e00 to avc_data (coverages) and then to SpatialPolygonsDAtaframe in sp_data

e00_to_SpatialPolygonDataframe <- function(x){
  for(i in x) {
    
    ## names
    e00file <- paste0("e00_data/", i, ".e00")
    spfile <- paste0("sp_data/", i, ".Rdata")
    avcdir <- paste0("avc_data/", i)
    if(!dir.exists(avcdir)) dir.create(avcdir)
    
    ## raw data
    raw <- readLines(e00file) # reads E00 file
    attr.tab <- attrTab(raw) # used attrTab (and eggAttr) functions to make attr.tab
    
    ## get data from  e00 file
    con <- try(e00toavc(e00file, file.path(avcdir, "bin")))
    arc <- try(get.arcdata(avcdir, "bin"))
    pal <- try(get.paldata(avcdir, "bin"))
    pat <- try(get.tabledata(file.path(avcdir, "info"), "bin.PAT")) # get.tablenames(file.path(avcdir, "info"))
    
    if(all(c(class(arc), class(pal)) != "try-error")) {
      
      ## convert data to spatial polygons
      lcc.proj <- "+proj=lcc +lat_1=49 +lat_2=77 +lat_0=40 +lon_0=-100 +x_0=0 +y_0=0 +datum=NAD27 +ellps=clrk66 +units=m +no_defs"
      ice <- pal2SpatialPolygons(arc,
                                 pal,
                                 pal[[1]]$PolygonId[-1],
                                 dropPoly1=TRUE,
                                 proj4string=CRS(lcc.proj))
      
      if(class(pat) != "try-error") {
        ## add table data to make spatial polygons data frame
        dat <- lapply(names(pat), function(i) {
          if(is.character(pat[[i]])) {
            gsub(pattern = "^\\s+|\\s+$", replacement = "", pat[[i]])
          } else {
            pat[[i]]
          }
        })
        dat <- do.call(cbind.data.frame, dat)
        names(dat) <- gsub(" ", "", names(pat))
        dat <- dat[-1, ] # discard first row
        dat[dat == ""] <- NA
        dat$ID <- as.character(seq(nrow(dat)))
      } else {
        ids <- data.frame(ID = sapply(slot(ice, "polygons"), function(x) slot(x, "ID")))
        ids <- na.omit(ids)
        dat <- merge(ids, attr.tab, by = "ID", all.x = TRUE)
        dat <- dat[order(as.numeric(dat$ID)),]
        dat$A_LEGEND[is.na(dat$A_LEGEND)] <- "No data"
        row.names(dat) <- dat$ID
      }
      ice <- try(SpatialPolygonsDataFrame(ice, data = dat))
      try(plotIce(ice, main = i))
      
      ## use cleangeo package to clean-up geometry errors
      ice <- try(clgeo_Clean(ice))
      
      ## save Rdata
      if(class(ice) != "try-error") {
        save(ice, file = spfile)
      }
    }
  }
}

# there appear to be two main types of errors---------------
# 1) 4 errors for one file
#Error in e00toavc(e00file, file.path(avcdir, "bin")) : 
 # ERROR 4: Unable to create coverage directory: avc_data/19730528/bin.

#Error in get.arcdata(avcdir, "bin") : 
 # ERROR 3: Attempt to read past EOF in avc_data/19730528\bin\arc.adf.

#Error in get.paldata(avcdir, "bin") : 
 # ERROR 4: Failed to open file avc_data/19730528\bin\pal.adf

#Error in get.tabledata(file.path(avcdir, "info"), "bin.PAT") : 
  #ERROR 3: Attempt to read past EOF in avc_data/19730528/info\arc.dir.
# these vary from file to file and sometimes, the error is different, e.g.
# Error in get.tabledata(file.path(avcdir, "info"), "bin.PAT") : 
# ERROR 3: Attempt to read past EOF in avc_data/19780423/info\arc.dir.


# 2) This error is less important - we have gone through the work and downloaded teh files but it would be ncie to solve for the future
#Error in file(con, "r") : cannot open the connection
#In addition: Warning message:
# In file(con, "r") :
#  cannot open file 'e00_data/19730604.e00': Too many open files



##' calcAreaVolume() ------------------------------------------------
#' Calculate Area and Volume of ice based on RData files with subsets
#'
#' @param y = a vector of dates
#' @param ... parameters from iceArea, eggAttr.cols, and eggAttr.query
#'
#' @return list with estimates of ice area and volume
#' @export
#'
#' @examples
 calcAreaVolume <- function(y, ct = NULL, sa = NULL){
   areas <- volumes <- rep(NA, length(y)) # create an empty object
   for(i in seq_along(y)) {
     
     ## load map data
     print(y[i])                   #start here when making single object for testing
     load(format(y[i], "sp_data/%Y%m%d.Rdata"))
     #plotIce(ice, main = dates[i])
     
     ## set area and volume to 0 if no egg attributes
     if(all(is.na(ice$EGG_ATTR))) {  # START HERE
       area <- volume <- 0
     } else {
       
       ## subset and project
       egg <- ice[!is.na(ice$EGG_ATTR), ]  # subset here???
       egg <- spTransform(egg, CRS("+proj=longlat +datum=WGS84"))
       
       ## Apply filters
       attr.tab <- egg@data
       sub.egg <- try(gDifference(egg, filters, byid = TRUE))
       if(class(sub.egg) == "try-error") {
         buf.egg <- try(gBuffer(egg, byid = TRUE, width = 0)) # adding a small buffer often fixes geo issues
         sub.egg <- try(gDifference(buf.egg, filters, byid = TRUE))
       }
       if(class(sub.egg) != "try-error" & !is.null(sub.egg)) {
         row.names(attr.tab) <- paste(row.names(attr.tab), "- filters")
         attr.tab <- attr.tab[names(sub.egg), ]
         sub.egg <- SpatialPolygonsDataFrame(sub.egg, attr.tab) # recover data
       }
       if(class(sub.egg) == "try-error") { stop("There was a problem applying the filters") }
       if(is.null(sub.egg)) { area <- volume <- 0 }
       
       ## proceed with area and volume calculations
       if(is.null(sub.egg)) {
         area <- volume <- 0 # if NULL, then no ice was below 55 deg North
       } else {
         
         if(class(sub.egg) != "try-error") {
           ## return to lcc projection and calculate area and volume
           sub.egg <- spTransform(sub.egg, CRS(proj4string(ice)))
           a <- try(gArea(sub.egg, byid = TRUE)) # sometimes holes are not identified correctly, so try and extract max polygon area within each id
           if(class(a) == "try-error") { 
             message("gArea didn't work. Trying alternate appriach")
             a <- sapply(slot(sub.egg, "polygons"), function(x) max(sapply(slot(x, "Polygons"), slot, "area"))) 
           }
           if(class(a) != "try-error") {
             sub.egg$AREA <- a * 1e-6 # replace polygon area (use square km)
             test <- iceArea(sub.egg@data, ct = ct, sa = sa)
             area <- test[[2]]
             volume <- iceVolume(sub.egg@data) 
           } else {
             area <- volume <- NA
           }
         } else { 
           area <- volume <- NA 
         }
       }
     } #end here when making single object for testing
     
     areas[i] <- area
     volumes[i] <- volume
     
   }
   list(areas = areas, volumes = volumes)
 }
 


##' multiplot()--------- 
#' - like mfrow
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}


## lookAt() -----------------------------------------------------
# copied from http://r.789695.n4.nabble.com/List-of-Levels-for-all-Factor-variables-td4646355.html
# use this in the Look at Data function to print out levels of all factor variables
PrintLvls <- function(x) {print(data.frame(Lvls=sapply(x[sapply(x,is.factor)],nlevels), 
                                           Names=sapply(x[sapply(x, is.factor)], 
                                                        function(y) paste0(levels(y), collapse=", "))), right=FALSE) 
} 
####################################################################################
#' Look At Data
#'
#' @param x 
#'
#' @return
#' @export
#'
#' @examples - lookAt(iris) # prints head of data set and structure

lookAt <- function(x) {
  print(head(x))
  cat("\n")
  str(x)
  cat("\n")
  cat("Names of levels in Factor Variables")
  cat("\n")
  PrintLvls(x) #see above for code
}

####################################################################################

## lookAtSubEgg() -------------
#' Look At the STructure of a sub.egg object
#'
#' @param z = a vector of dates
#' @param i = a datum in the vector
#'
#' @return a sub.egg object
#' @export
#'
#' @examples
lookATSubEgg <- function(z, i){
  ## load map data
  print(z[i])                   #start here when making single object for testing
  load(format(z[i], "sp_data/%Y%m%d.Rdata"))
  #plotIce(ice, main = dates[i])
  iceLook <- ice
  showIce <- ice@data[, c("AREA", "A_LEGEND", "EGG_ATTR", "E_CT", "E_CA", "E_SA", "E_SB")]
  return(list(a=iceLook, b=showIce))
}


